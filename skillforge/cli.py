"""CLI entry point with setup commands."""

import os
import sys
from pathlib import Path

import click
from dotenv import load_dotenv
from rich.console import Console
from rich.panel import Panel
from rich.table import Table

# Load .env before any config access
load_dotenv()

console = Console()


def _print_step(step: int, total: int, message: str) -> None:
    console.print(f"[bold blue][{step}/{total}][/] {message}")


def _print_success(message: str) -> None:
    console.print(f"  [green]✓[/] {message}")


def _print_warning(message: str) -> None:
    console.print(f"  [yellow]![/] {message}")


def _print_error(message: str) -> None:
    console.print(f"  [red]✗[/] {message}")


@click.group(invoke_without_command=True)
@click.pass_context
@click.version_option(version="0.1.0", prog_name="skillforge")
def cli(ctx):
    """
    Skillforge - Generate AI agent skills from documentation.

    \b
    Quick start:
      skillforge init          # Set up API keys
      skillforge doctor        # Verify configuration
      skillforge run "task"    # Generate a skill

    \b
    Examples:
      skillforge run "use the Stripe API to create subscriptions"
      skillforge run "build CUDA kernels" --seed https://docs.nvidia.com/cuda
    """
    if ctx.invoked_subcommand is None:
        click.echo(ctx.get_help())


@cli.command()
@click.option("--force", "-f", is_flag=True, help="Overwrite existing .env file")
def init(force: bool):
    """Initialize Skillforge with API keys.

    Creates a .env file with your ANTHROPIC_API_KEY and FIRECRAWL_API_KEY.
    """
    env_path = Path.cwd() / ".env"

    if env_path.exists() and not force:
        console.print("[yellow]A .env file already exists.[/]")
        console.print("Use [bold]--force[/] to overwrite, or edit .env directly.")
        console.print()
        console.print("Run [bold]skillforge doctor[/] to verify your setup.")
        return

    console.print(Panel(
        "[bold]Welcome to Skillforge![/]\n\n"
        "This wizard will help you configure your API keys.\n"
        "You'll need:\n"
        "  • [cyan]ANTHROPIC_API_KEY[/] - Get one at https://console.anthropic.com\n"
        "  • [cyan]FIRECRAWL_API_KEY[/] - Get one at https://firecrawl.dev",
        title="Setup",
        border_style="blue",
    ))
    console.print()

    # Get Anthropic API key
    anthropic_key = os.environ.get("ANTHROPIC_API_KEY", "")
    if anthropic_key:
        console.print(f"[dim]Found existing ANTHROPIC_API_KEY: {anthropic_key[:8]}...{anthropic_key[-4:]}[/]")
        use_existing = click.confirm("Use existing key?", default=True)
        if not use_existing:
            anthropic_key = ""

    if not anthropic_key:
        anthropic_key = click.prompt(
            "Enter your Anthropic API key",
            hide_input=True,
        )

    # Get Firecrawl API key
    firecrawl_key = os.environ.get("FIRECRAWL_API_KEY", "")
    if firecrawl_key:
        console.print(f"[dim]Found existing FIRECRAWL_API_KEY: {firecrawl_key[:8]}...{firecrawl_key[-4:]}[/]")
        use_existing = click.confirm("Use existing key?", default=True)
        if not use_existing:
            firecrawl_key = ""

    if not firecrawl_key:
        firecrawl_key = click.prompt(
            "Enter your Firecrawl API key",
            hide_input=True,
        )

    # Write .env file
    env_content = f"""# Skillforge API Keys
# Generated by: skillforge init

ANTHROPIC_API_KEY={anthropic_key}
FIRECRAWL_API_KEY={firecrawl_key}
"""

    env_path.write_text(env_content)
    console.print()
    console.print(f"[green]✓[/] Created {env_path}")
    console.print()
    console.print("Next steps:")
    console.print("  1. Run [bold]skillforge doctor[/] to verify configuration")
    console.print("  2. Run [bold]skillforge run \"your task\"[/] to generate a skill")


@cli.command()
def doctor():
    """Check if Skillforge is configured correctly.

    Verifies API keys and connectivity.
    """
    console.print(Panel(
        "[bold]Checking Skillforge configuration...[/]",
        title="Doctor",
        border_style="blue",
    ))
    console.print()

    issues = []
    warnings = []

    # Check Python version
    py_version = sys.version_info
    if py_version >= (3, 12):
        _print_success(f"Python {py_version.major}.{py_version.minor}.{py_version.micro}")
    else:
        _print_error(f"Python {py_version.major}.{py_version.minor} (need 3.12+)")
        issues.append("Python 3.12+ required")

    # Check .env file
    env_path = Path.cwd() / ".env"
    if env_path.exists():
        _print_success(f".env file found")
    else:
        _print_warning(".env file not found (checking environment)")
        warnings.append("No .env file - relying on environment variables")

    # Check Anthropic API key
    anthropic_key = os.environ.get("ANTHROPIC_API_KEY", "")
    if anthropic_key:
        _print_success(f"ANTHROPIC_API_KEY set ({anthropic_key[:8]}...)")
        # Test API connectivity
        try:
            from anthropic import Anthropic
            client = Anthropic(api_key=anthropic_key)
            # Just verify the key format is valid (actual API call would cost money)
            if anthropic_key.startswith("sk-ant-"):
                _print_success("  Key format looks valid")
            else:
                _print_warning("  Key format unusual (expected sk-ant-...)")
                warnings.append("Anthropic key format looks unusual")
        except Exception as e:
            _print_error(f"  Failed to initialize client: {e}")
            issues.append(f"Anthropic client error: {e}")
    else:
        _print_error("ANTHROPIC_API_KEY not set")
        issues.append("ANTHROPIC_API_KEY not configured")

    # Check Firecrawl API key
    firecrawl_key = os.environ.get("FIRECRAWL_API_KEY", "")
    if firecrawl_key:
        _print_success(f"FIRECRAWL_API_KEY set ({firecrawl_key[:8]}...)")
        try:
            from firecrawl import Firecrawl
            client = Firecrawl(api_key=firecrawl_key)
            if firecrawl_key.startswith("fc-"):
                _print_success("  Key format looks valid")
            else:
                _print_warning("  Key format unusual (expected fc-...)")
                warnings.append("Firecrawl key format looks unusual")
        except Exception as e:
            _print_error(f"  Failed to initialize client: {e}")
            issues.append(f"Firecrawl client error: {e}")
    else:
        _print_error("FIRECRAWL_API_KEY not set")
        issues.append("FIRECRAWL_API_KEY not configured")

    # Check output directories
    skills_dir = Path.cwd() / "skills"
    corpus_dir = Path.cwd() / "corpus"
    if skills_dir.exists():
        skill_count = sum(1 for _ in skills_dir.iterdir()) if skills_dir.is_dir() else 0
        _print_success(f"skills/ directory ({skill_count} skills)")
    else:
        _print_warning("skills/ directory will be created on first run")

    if corpus_dir.exists():
        corpus_count = sum(1 for _ in corpus_dir.iterdir()) if corpus_dir.is_dir() else 0
        _print_success(f"corpus/ directory ({corpus_count} corpora)")
    else:
        _print_warning("corpus/ directory will be created on first run")

    # Summary
    console.print()
    if issues:
        console.print(Panel(
            "[bold red]Issues found:[/]\n" + "\n".join(f"  • {i}" for i in issues) +
            "\n\n[bold]Run:[/] skillforge init",
            title="✗ Not Ready",
            border_style="red",
        ))
        raise SystemExit(1)
    elif warnings:
        console.print(Panel(
            "[bold yellow]Warnings:[/]\n" + "\n".join(f"  • {w}" for w in warnings) +
            "\n\n[bold]Skillforge should work, but check warnings above.[/]",
            title="⚠ Ready (with warnings)",
            border_style="yellow",
        ))
    else:
        console.print(Panel(
            "[bold green]All checks passed![/]\n\n"
            "[bold]Run:[/] skillforge run \"your task description\"",
            title="✓ Ready",
            border_style="green",
        ))


@cli.command()
@click.argument("task")
@click.option("--seed", required=False, help="Seed documentation URL (optional - auto-discovers if omitted)")
@click.option(
    "--model",
    default="claude-sonnet-4-20250514",
    help="Model to use for teacher session",
)
@click.option("--max-attempts", default=10, help="Maximum teacher session attempts")
@click.option("--corpus-limit", default=50, help="Maximum pages to crawl")
@click.option("--stealth", is_flag=True, help="Use stealth proxies for anti-bot protected sites (9x cost)")
@click.option(
    "--fast",
    is_flag=True,
    help="Speed-optimized mode (smaller discovery/corpus limits for demos)",
)
@click.option(
    "--no-sandbox",
    is_flag=True,
    help="Disable sandbox shadow validation for TASK_COMPLETE outputs",
)
@click.option("--verbose", "-v", is_flag=True, help="Verbose output")
def run(
    task: str,
    seed: str | None,
    model: str,
    max_attempts: int,
    corpus_limit: int,
    stealth: bool,
    fast: bool,
    no_sandbox: bool,
    verbose: bool,
) -> None:
    """
    Generate a SKILL.md file from a task description.

    \b
    TASK: Description of the task to learn (e.g., "build CUDA kernels")

    \b
    Examples:
      skillforge run "use the Stripe API to create subscriptions"
      skillforge run "build CUDA kernels" --seed https://docs.nvidia.com/cuda
      skillforge run "use Firecrawl to crawl webpages" --fast -v
    """
    # Import here to avoid slow startup for help/init/doctor
    from .config import validate_config
    from .discovery import discover_sources, discover_sources_from_task
    from .sandbox_runner import run_sandbox_validation
    from .corpus import build_corpus
    from .teacher import run_teacher_session
    from .validation import validate_or_raise
    from .generator import generate_skill
    from .exceptions import SkillForgeError

    try:
        # Step 1: Validate config
        _print_step(1, 6, "Validating configuration...")
        validate_config()
        _print_success("Configuration valid")

        # Step 2: Discover sources
        discovery_map_limit = 200
        discovery_search_limit = 5
        discovery_max_seeds = 3
        effective_corpus_limit = corpus_limit

        if fast:
            discovery_map_limit = 50
            discovery_search_limit = 3
            discovery_max_seeds = 1
            effective_corpus_limit = min(corpus_limit, 20)
            if verbose:
                console.print("    [yellow]Fast mode enabled: reduced discovery and corpus limits[/]")

        if seed:
            _print_step(2, 6, f"Discovering sources from seed: {seed}")
            sources = discover_sources(
                task,
                seed,
                map_limit=discovery_map_limit,
                search_limit=discovery_search_limit,
            )
        else:
            _print_step(2, 6, "Auto-discovering documentation sources...")
            sources = discover_sources_from_task(
                task,
                max_seeds=discovery_max_seeds,
                search_limit=discovery_search_limit,
                map_limit=discovery_map_limit,
            )
        _print_success(f"Found {len(sources)} sources")
        if verbose:
            # Show tier breakdown
            tier_1 = sum(1 for s in sources if s.tier.value == 1)
            tier_2 = sum(1 for s in sources if s.tier.value == 2)
            tier_3 = sum(1 for s in sources if s.tier.value == 3)
            console.print(f"    Tier 1 (critical): {tier_1}, Tier 2 (supporting): {tier_2}, Tier 3 (context): {tier_3}")
            for s in sources[:5]:
                console.print(f"    - [T{s.tier.value}] {s.url}")
            if len(sources) > 5:
                console.print(f"    ... and {len(sources) - 5} more")

        # Step 3: Build corpus
        _print_step(3, 6, "Building documentation corpus...")
        if stealth and verbose:
            console.print("    [yellow]Stealth mode enabled (9x crawl cost)[/]")
        corpus_path = build_corpus(task, sources, limit=effective_corpus_limit, stealth=stealth)
        _print_success(f"Corpus created at {corpus_path.name}")
        if verbose:
            import json
            manifest = json.loads((corpus_path / "manifest.json").read_text())
            console.print(f"    Pages: {manifest['total_pages']}")
            console.print(f"    Est. tokens: {manifest['total_tokens_estimate']:,}")
            if "tier_breakdown" in manifest:
                tb = manifest["tier_breakdown"]
                console.print(f"    Tiers: T1={tb['tier_1_critical']}, T2={tb['tier_2_supporting']}, T3={tb['tier_3_context']}")

        # Step 4: Teacher session
        _print_step(4, 6, "Running teacher session...")

        def on_attempt(attempt: int, outcome):
            if outcome.success:
                _print_success(f"Attempt {attempt}: Task completed")
            elif outcome.gap_query:
                _print_warning(f"Attempt {attempt}: Gap found - {outcome.gap_query}")
            else:
                _print_warning(f"Attempt {attempt}: No gap identified")

        result = run_teacher_session(
            task=task,
            corpus_path=corpus_path,
            model=model,
            max_attempts=max_attempts,
            verbose=verbose,
            on_attempt=on_attempt if verbose else None,
            sandbox_runner=None if no_sandbox else run_sandbox_validation,
            stealth=stealth,
        )
        _print_success(f"Completed in {result.attempts} attempt(s)")
        if result.gaps_filled:
            console.print(f"    Gaps filled: {', '.join(result.gaps_filled)}")

        # Step 5: Validate output
        _print_step(5, 6, "Validating teacher output...")
        validation = validate_or_raise(result)
        _print_success(f"Validation passed ({validation.checks_passed}/{validation.checks_run} checks)")
        if verbose and validation.warnings:
            for warning in validation.warnings:
                _print_warning(warning)

        # Step 6: Generate skill
        _print_step(6, 6, "Generating SKILL.md...")
        skill_path = generate_skill(task, result, corpus_path)
        _print_success(f"Skill saved to {skill_path}")

        # Final summary
        console.print()
        console.print(
            Panel(
                f"[bold green]Skill generated successfully![/]\n\n"
                f"[bold]Location:[/] {skill_path}\n"
                f"[bold]Files:[/]\n"
                f"  • SKILL.md\n"
                f"  • tests.json\n"
                f"  • skill_manifest.json\n\n"
                f"[bold]Corpus:[/] {corpus_path}",
                title="Done",
                border_style="green",
            )
        )

    except SkillForgeError as e:
        console.print()
        console.print(f"[bold red]Error:[/] {e}")
        raise SystemExit(1)
    except KeyboardInterrupt:
        console.print()
        console.print("[yellow]Interrupted[/]")
        raise SystemExit(130)


@cli.command(name="list")
def list_skills():
    """List generated skills."""
    skills_dir = Path.cwd() / "skills"

    if not skills_dir.exists():
        console.print("[yellow]No skills directory found.[/]")
        console.print("Run [bold]skillforge run \"task\"[/] to generate your first skill.")
        return

    skill_dirs = [d for d in skills_dir.iterdir() if d.is_dir() and (d / "SKILL.md").exists()]

    if not skill_dirs:
        console.print("[yellow]No skills found.[/]")
        console.print("Run [bold]skillforge run \"task\"[/] to generate your first skill.")
        return

    table = Table(title="Generated Skills")
    table.add_column("Name", style="cyan")
    table.add_column("Created", style="dim")
    table.add_column("Files", style="green")

    for skill_path in sorted(skill_dirs, key=lambda p: p.stat().st_mtime, reverse=True):
        import datetime
        mtime = datetime.datetime.fromtimestamp(skill_path.stat().st_mtime)
        file_count = sum(1 for _ in skill_path.iterdir())
        table.add_row(
            skill_path.name,
            mtime.strftime("%Y-%m-%d %H:%M"),
            str(file_count),
        )

    console.print(table)


# Keep backward compatibility: allow `skillforge "task"` without `run`
@cli.command(name="generate", hidden=True)
@click.argument("task")
@click.pass_context
def generate_compat(ctx, task):
    """Hidden command for backward compatibility."""
    ctx.invoke(run, task=task)


def main():
    """Entry point that supports both old and new CLI styles."""
    # Check if first arg looks like a task (not a subcommand)
    if len(sys.argv) > 1 and sys.argv[1] not in ["init", "doctor", "run", "list", "--help", "-h", "--version"]:
        # Insert 'run' for backward compatibility: `skillforge "task"` -> `skillforge run "task"`
        sys.argv.insert(1, "run")
    cli()


if __name__ == "__main__":
    main()
